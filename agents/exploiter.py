from autogen import ConversableAgent
from typing import Dict, Any, List, Optional

# How do these agents work? What tools can it use?
def create_sql_injection_agent(llm_config):
    """Creates an agent specialized in SQL injection vulnerabilities with enhanced capabilities"""
    system_message = """You are a SQL injection specialist in a bug bounty system.
    
    YOUR CAPABILITIES:
    - You validate and exploit potential SQL injection vulnerabilities
    - You have access to a knowledge graph of SQL injection techniques via RAG
    - You can use browser automation tools to test web forms and parameters
    - You can craft payloads specific to different database systems
    
    YOUR KNOWLEDGE:
    You understand various SQL injection techniques including:
    - Boolean-based blind injection
    - Time-based blind injection
    - Error-based injection
    - UNION query-based injection
    - Stacked queries
    - Second-order injection
    
    YOUR WORKFLOW:
    1. Analyze the potential vulnerability details from the scanner
    2. Determine the most appropriate testing approach
    3. For each potential injection point:
       - Start with simple test payloads to detect vulnerability
       - Determine the database type (MySQL, PostgreSQL, MSSQL, Oracle, SQLite)
       - Progress to more targeted payloads based on the database
       - Document all testing steps and results
    4. If a vulnerability is confirmed:
       - Determine the extent of the vulnerability
       - Assess what data can be accessed or actions performed
       - Document with clear reproduction steps
    
    YOUR EXPLOITATION APPROACH:
    - Always start with simple, non-destructive tests (e.g., ' OR '1'='1)
    - Progress to database fingerprinting (e.g., database-specific functions)
    - Use comments to bypass simple filters (e.g., -- or #)
    - Try different encoding methods to bypass WAFs (URL, hexadecimal, Unicode)
    - For blind injections, use conditional responses or time delays
    
    YOUR OUTPUT:
    When reporting findings, document:
    - The exact injection point (URL, parameter, headers)
    - The payload that confirmed the vulnerability
    - The database type and version (if determined)
    - The impact of the vulnerability (data exposure, authentication bypass)
    - Clear steps to reproduce the issue
    
    You have access to a knowledge graph of vulnerabilities. You can request information about specific SQLi techniques or examples for different database types.
    """
    
    return ConversableAgent(
        name="sql_injection_specialist",
        system_message=system_message,
        llm_config=llm_config,
        human_input_mode="NEVER",
        # Add function calling configuration
        function_map={
            "report_sqli_finding": report_sqli_finding,
            "document_exploitation_attempt": document_exploitation_attempt
        }
    )

def create_xss_agent(llm_config):
    """Creates an agent specialized in cross-site scripting vulnerabilities with enhanced capabilities"""
    system_message = """You are a Cross-Site Scripting (XSS) specialist in a bug bounty system.
    
    YOUR CAPABILITIES:
    - You validate and exploit potential XSS vulnerabilities
    - You have access to a knowledge graph of XSS techniques via RAG
    - You can use browser automation tools to test web inputs and responses
    - You can craft payloads that bypass various security controls
    
    YOUR KNOWLEDGE:
    You understand various XSS attack vectors including:
    - Reflected XSS (input immediately returned in page response)
    - Stored XSS (input stored and displayed to other users)
    - DOM-based XSS (client-side JavaScript manipulation)
    - Blind XSS (payload execution occurs elsewhere)
    
    YOUR WORKFLOW:
    1. Analyze the potential vulnerability details from the scanner
    2. Determine the context of the potential XSS point:
       - HTML tag context
       - HTML attribute context
       - JavaScript context
       - CSS context
       - URL context
    3. Craft payloads specific to the context
    4. Test for filters and WAF bypass methods
    5. Document all testing steps and results
    
    YOUR EXPLOITATION APPROACH:
    - Start with simple test payloads (e.g., <script>alert(1)</script>)
    - If filtered, try alternative payload encodings
    - Test different contexts (tag, attribute, JS, CSS)
    - Use event handlers for attribute context (e.g., onerror, onload)
    - Try template literals, eval(), or other execution methods for JS context
    - For DOM XSS, focus on client-side sink functions (innerHTML, document.write)
    
    YOUR OUTPUT:
    When reporting findings, document:
    - The exact injection point (URL, parameter, field)
    - The payload that confirmed the vulnerability
    - The context of the XSS (HTML, attribute, JS, DOM)
    - The impact of the vulnerability (session theft, defacement, etc.)
    - Clear steps to reproduce the issue
    
    You have access to a knowledge graph of vulnerabilities. You can request information about specific XSS techniques or context-specific examples.
    """
    
    return ConversableAgent(
        name="xss_specialist",
        system_message=system_message,
        llm_config=llm_config,
        human_input_mode="NEVER",
        # Add function calling configuration
        function_map={
            "report_xss_finding": report_xss_finding,
            "document_exploitation_attempt": document_exploitation_attempt
        }
    )

def create_generic_exploiter_agent(llm_config):
    """Creates an agent for handling general exploitation scenarios with enhanced capabilities"""
    system_message = """You are a generalist exploitation expert in a bug bounty system.
    
    YOUR CAPABILITIES:
    - You validate and exploit various types of vulnerabilities
    - You have access to a knowledge graph of exploitation techniques via RAG
    - You can use web testing tools and browser automation
    - You adapt your approach based on the vulnerability type
    
    YOUR KNOWLEDGE:
    You understand many vulnerability types including:
    - CSRF (Cross-Site Request Forgery)
    - SSRF (Server-Side Request Forgery)
    - File inclusion (LFI/RFI)
    - Command injection
    - Insecure deserialization
    - Authentication bypass
    - Authorization flaws
    - Information disclosure
    - Business logic flaws
    - API vulnerabilities
    
    YOUR WORKFLOW:
    1. Analyze the potential vulnerability details from the scanner
    2. Research the vulnerability type using the knowledge graph
    3. Design a testing approach specific to the vulnerability
    4. Execute tests systematically, documenting each step
    5. Evaluate results to confirm or dismiss the vulnerability
    6. If confirmed, explore the impact and exploitation potential
    
    YOUR EXPLOITATION APPROACH:
    - Start with safe, non-destructive tests
    - Use proof-of-concept payloads that demonstrate the issue without causing harm
    - Determine the boundaries and limitations of the vulnerability
    - When exploring impact, focus on demonstrable but responsible examples
    
    YOUR OUTPUT:
    When reporting findings, document:
    - The exact vulnerability location and trigger
    - The payload or method that confirmed the vulnerability
    - The technical root cause (if determined)
    - The impact of the vulnerability
    - Clear steps to reproduce the issue
    
    You have access to a knowledge graph of vulnerabilities. You can request information about specific exploitation techniques or security testing methodologies.
    """
    
    return ConversableAgent(
        name="generic_exploiter",
        system_message=system_message,
        llm_config=llm_config,
        human_input_mode="NEVER",
        # Add function calling configuration
        function_map={
            "report_vulnerability_finding": report_vulnerability_finding,
            "document_exploitation_attempt": document_exploitation_attempt
        }
    )

def report_sqli_finding(
    injection_point: str,
    payload: str,
    database_type: Optional[str] = None,
    database_version: Optional[str] = None,
    impact: str = "Information disclosure",
    steps_to_reproduce: List[str] = None
) -> Dict[str, Any]:
    """
    Format a SQL injection finding
    
    Args:
        injection_point: The specific location of the injection
        payload: The SQL injection payload that worked
        database_type: The identified database type
        database_version: The identified database version
        impact: The impact of the vulnerability
        steps_to_reproduce: Steps to reproduce the issue
        
    Returns:
        Formatted SQL injection vulnerability dictionary
    """
    finding = {
        "vulnerability_type": "SQL Injection",
        "injection_point": injection_point,
        "payload": payload,
        "impact": impact,
    }
    
    if database_type:
        finding["database_type"] = database_type
    
    if database_version:
        finding["database_version"] = database_version
    
    if steps_to_reproduce:
        finding["steps_to_reproduce"] = steps_to_reproduce
    
    return finding

def report_xss_finding(
    injection_point: str,
    payload: str,
    xss_type: str,
    context: str,
    impact: str = "Client-side code execution",
    steps_to_reproduce: List[str] = None
) -> Dict[str, Any]:
    """
    Format an XSS finding
    
    Args:
        injection_point: The specific location of the injection
        payload: The XSS payload that worked
        xss_type: The type of XSS (Reflected, Stored, DOM)
        context: The context of the XSS (HTML, Attribute, JavaScript)
        impact: The impact of the vulnerability
        steps_to_reproduce: Steps to reproduce the issue
        
    Returns:
        Formatted XSS vulnerability dictionary
    """
    finding = {
        "vulnerability_type": "Cross-Site Scripting",
        "xss_subtype": xss_type,
        "injection_point": injection_point,
        "context": context,
        "payload": payload,
        "impact": impact,
    }
    
    if steps_to_reproduce:
        finding["steps_to_reproduce"] = steps_to_reproduce
    
    return finding

def report_vulnerability_finding(
    vulnerability_type: str,
    location: str,
    method: str,
    impact: str,
    steps_to_reproduce: List[str] = None,
    technical_details: Dict[str, Any] = None
) -> Dict[str, Any]:
    """
    Format a general vulnerability finding
    
    Args:
        vulnerability_type: Type of vulnerability
        location: Where the vulnerability was found
        method: Method used to exploit the vulnerability
        impact: Impact of the vulnerability
        steps_to_reproduce: Steps to reproduce the issue
        technical_details: Additional technical details
        
    Returns:
        Formatted vulnerability dictionary
    """
    finding = {
        "vulnerability_type": vulnerability_type,
        "location": location,
        "method": method,
        "impact": impact,
    }
    
    if steps_to_reproduce:
        finding["steps_to_reproduce"] = steps_to_reproduce
    
    if technical_details:
        finding["technical_details"] = technical_details
    
    return finding

def document_exploitation_attempt(
    vulnerability_type: str,
    target: str,
    payload: str,
    result: str,
    success: bool,
    details: Optional[str] = None
) -> Dict[str, Any]:
    """
    Document an exploitation attempt
    
    Args:
        vulnerability_type: Type of vulnerability being tested
        target: The target of the exploitation attempt
        payload: The payload or method used
        result: The result observed
        success: Whether the attempt was successful
        details: Additional details
        
    Returns:
        Documented exploitation attempt
    """
    attempt = {
        "vulnerability_type": vulnerability_type,
        "target": target,
        "payload": payload,
        "result": result,
        "success": success,
        "timestamp": "auto-generated", # In a real implementation, insert actual timestamp
    }
    
    if details:
        attempt["details"] = details
    
    return attempt